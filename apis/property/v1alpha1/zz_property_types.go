/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CertStatusObservation struct {
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	ProductionStatus *string `json:"productionStatus,omitempty" tf:"production_status,omitempty"`

	StagingStatus *string `json:"stagingStatus,omitempty" tf:"staging_status,omitempty"`

	Target *string `json:"target,omitempty" tf:"target,omitempty"`
}

type CertStatusParameters struct {
}

type HostnamesObservation struct {
	EdgeHostnameID *string `json:"edgeHostnameId,omitempty" tf:"edge_hostname_id,omitempty"`
}

type HostnamesParameters struct {

	// +kubebuilder:validation:Required
	CertProvisioningType *string `json:"certProvisioningType" tf:"cert_provisioning_type,omitempty"`

	// +kubebuilder:validation:Optional
	CertStatus []CertStatusParameters `json:"certStatus,omitempty" tf:"cert_status,omitempty"`

	// +kubebuilder:validation:Required
	CnameFrom *string `json:"cnameFrom" tf:"cname_from,omitempty"`

	// +kubebuilder:validation:Required
	CnameTo *string `json:"cnameTo" tf:"cname_to,omitempty"`

	// +kubebuilder:validation:Optional
	CnameType *string `json:"cnameType,omitempty" tf:"cname_type,omitempty"`
}

type OriginObservation struct {
}

type OriginParameters struct {

	// +kubebuilder:validation:Optional
	CacheKeyHostname *string `json:"cacheKeyHostname,omitempty" tf:"cache_key_hostname,omitempty"`

	// +kubebuilder:validation:Optional
	Compress *bool `json:"compress,omitempty" tf:"compress,omitempty"`

	// +kubebuilder:validation:Optional
	EnableTrueClientIP *bool `json:"enableTrueClientIp,omitempty" tf:"enable_true_client_ip,omitempty"`

	// +kubebuilder:validation:Optional
	ForwardHostname *string `json:"forwardHostname,omitempty" tf:"forward_hostname,omitempty"`

	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`
}

type PropertyObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	LatestVersion *int64 `json:"latestVersion,omitempty" tf:"latest_version,omitempty"`

	ProductionVersion *int64 `json:"productionVersion,omitempty" tf:"production_version,omitempty"`

	ReadVersion *int64 `json:"readVersion,omitempty" tf:"read_version,omitempty"`

	RuleErrors []RuleErrorsObservation `json:"ruleErrors,omitempty" tf:"rule_errors,omitempty"`

	StagingVersion *int64 `json:"stagingVersion,omitempty" tf:"staging_version,omitempty"`
}

type PropertyParameters struct {

	// +kubebuilder:validation:Optional
	Contact []*string `json:"contact,omitempty" tf:"contact,omitempty"`

	// +kubebuilder:validation:Optional
	Contract *string `json:"contract,omitempty" tf:"contract,omitempty"`

	// Contract ID to be assigned to the Property
	// +kubebuilder:validation:Optional
	ContractID *string `json:"contractId,omitempty" tf:"contract_id,omitempty"`

	// +kubebuilder:validation:Optional
	CpCode *string `json:"cpCode,omitempty" tf:"cp_code,omitempty"`

	// +kubebuilder:validation:Optional
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// Group ID to be assigned to the Property
	// +kubebuilder:validation:Optional
	GroupID *string `json:"groupId,omitempty" tf:"group_id,omitempty"`

	// +kubebuilder:validation:Optional
	Hostnames []HostnamesParameters `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	// +kubebuilder:validation:Optional
	IsSecure *bool `json:"isSecure,omitempty" tf:"is_secure,omitempty"`

	// +kubebuilder:validation:Optional
	Origin []OriginParameters `json:"origin,omitempty" tf:"origin,omitempty"`

	// +kubebuilder:validation:Optional
	Product *string `json:"product,omitempty" tf:"product,omitempty"`

	// Product ID to be assigned to the Property
	// +kubebuilder:validation:Optional
	ProductID *string `json:"productId,omitempty" tf:"product_id,omitempty"`

	// Specify the rule format version (defaults to latest version available when created)
	// +kubebuilder:validation:Optional
	RuleFormat *string `json:"ruleFormat,omitempty" tf:"rule_format,omitempty"`

	// +kubebuilder:validation:Optional
	RuleWarnings []RuleWarningsParameters `json:"ruleWarnings,omitempty" tf:"rule_warnings,omitempty"`

	// Property Rules as JSON
	// +kubebuilder:validation:Optional
	Rules *string `json:"rules,omitempty" tf:"rules,omitempty"`

	// +kubebuilder:validation:Optional
	Variables *string `json:"variables,omitempty" tf:"variables,omitempty"`
}

type RuleErrorsObservation struct {
}

type RuleErrorsParameters struct {

	// +kubebuilder:validation:Optional
	BehaviorName *string `json:"behaviorName,omitempty" tf:"behavior_name,omitempty"`

	// +kubebuilder:validation:Optional
	Detail *string `json:"detail,omitempty" tf:"detail,omitempty"`

	// +kubebuilder:validation:Optional
	ErrorLocation *string `json:"errorLocation,omitempty" tf:"error_location,omitempty"`

	// +kubebuilder:validation:Optional
	Instance *string `json:"instance,omitempty" tf:"instance,omitempty"`

	// +kubebuilder:validation:Optional
	StatusCode *int64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	// +kubebuilder:validation:Optional
	Title *string `json:"title,omitempty" tf:"title,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RuleWarningsObservation struct {
}

type RuleWarningsParameters struct {

	// +kubebuilder:validation:Optional
	BehaviorName *string `json:"behaviorName,omitempty" tf:"behavior_name,omitempty"`

	// +kubebuilder:validation:Optional
	Detail *string `json:"detail,omitempty" tf:"detail,omitempty"`

	// +kubebuilder:validation:Optional
	ErrorLocation *string `json:"errorLocation,omitempty" tf:"error_location,omitempty"`

	// +kubebuilder:validation:Optional
	Instance *string `json:"instance,omitempty" tf:"instance,omitempty"`

	// +kubebuilder:validation:Optional
	StatusCode *int64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	// +kubebuilder:validation:Optional
	Title *string `json:"title,omitempty" tf:"title,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

// PropertySpec defines the desired state of Property
type PropertySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PropertyParameters `json:"forProvider"`
}

// PropertyStatus defines the observed state of Property.
type PropertyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PropertyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Property is the Schema for the Propertys API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,akamaijet}
type Property struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              PropertySpec   `json:"spec"`
	Status            PropertyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PropertyList contains a list of Propertys
type PropertyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Property `json:"items"`
}

// Repository type metadata.
var (
	Property_Kind             = "Property"
	Property_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Property_Kind}.String()
	Property_KindAPIVersion   = Property_Kind + "." + CRDGroupVersion.String()
	Property_GroupVersionKind = CRDGroupVersion.WithKind(Property_Kind)
)

func init() {
	SchemeBuilder.Register(&Property{}, &PropertyList{})
}
